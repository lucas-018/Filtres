\documentclass{report}

\usepackage[latin1]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{lmodern}
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\usepackage{graphicx}

\title{Rapport Projet TDLog}
\author{Oscar CLIVIO, Andrei KARTASHOV, Lucas BRIFAULT}

\begin{document}
\maketitle
\chapter*{Introduction}
\chapter*{Recherche des Filtres Audio}
\section*{Choix du langage de programmation}
\large
Dans le but de développer et tester différents filtres audios le plus rapidement possible, il nous fallait choisir un langage de programmation à la fois facile à manipuler et performant d'un point de vue "exigences scientifiques". Nous nous sommes alors naturellement orientés vers Python, qui en plus avait le mérite d'être bien connu de nous trois. Ce langage script dispose de surcroît de bibliothèques très pratiques pour la lecture et l'enregistrement de fichiers son, le traitement rapide du signal et l'analyse de la qualité des filtres créés (scipy, pylab, matplotlib...).
\section*{Les bases: le son}
\large
Avant de se lancer bille en tête dans la programmation d'une batterie de filtres, et comme nous l'a fortement suggéré notre encadrant, il s'agissait de bien comprendre, sinon de bien se rappeler ce qu'est le son et comment on peut l'interpréter.\\
Le son est une fluctuation de pression (le plus souvent dans l'air, mais ce peut être un autre milieu) selon certaines fréquences, fréquences qui vont, ou non, être captées par l'oreille humaine (domaine audible: $20 Hz$ - $20000 Hz$).
Le son peut être interprété de plusieurs façons, on a notamment:\\
-L'interprétation temporelle (courbe de la variation de pression en fonction du temps)\\
-L'interprétation fréquentielle (en considérant que le signal est une somme de sinusoïdes à différentes fréquences, phases et amplitudes)\\
\\
D'un point de vue plutôt "instrumental", on peut caractériser un son (ex: la voix) selon différents critères:\\
-La hauteur (la fondamentale)\\
-Le timbre (le spectre)\\
-L'enveloppe, qui est en quelque sorte la variation en amplitude des fluctuations, et qui correspond à la forme globale que prend la courbe temporelle du signal.\\
\\
On peut également considérer un signal discrétisé (échantillonné, comme c'est toujours le cas numériquement) comme la réalisation d'un nombre fini de variables aléatoires. Par exemple on peut voir le signal total comme la somme de vecteurs aléatoires correspondant à chaque source sonore. Cela est assez puissant, puisqu'il nous donne accès à des outils probabilistes comme l'indépendance, qui peut aider dans certains cas à séparer certaines sources...\\ 
\section*{Les bases: l'analyse du signal}
\large
Nous présentons ici des outils et algorithmes très classiques en traitement du signal, qui nous ont guidé dans le choix des filtre (faisabilité...).\\
\\
Bien sûr on commence avec la transformée de Fourier et la transformée de Fourier inverse, qui permettent justement (cf section ci-dessus) de passer de la représentation temporelle à la représentation fréquentielle du signal et réciproquement. Evidemment, on utilise ii les versions discrètes. Dans un soucis de rapidité, essentielle pour l'exécution des tests, et surtout pour la performance finale des filtres, nous n'avons pas utilisé la transformée simple, mais la "Fast Fourier Transform" (FFT) qui est un algorithme qui s'inspire du principe "divide and conquer", en calculant récursivement les transformées de sous-parties du signal discret (en séparant les indices pairs et les indices impairs du tableau contenant les points du signal). Cet algorithme est bien plus efficace, même si il nécessite en général qu'on lui fournisse en entrée un tableau dont la taille est une puissance de 2.
En ce qui concerne python, cet algorithme est déjà inclus dans la bibliothèque scipy, même si il est facilement programmable.\\
\\ 
Le second outil indispensable est la "Short Term Fourier Transform" (STFT), qui part du constat suivant: la transformée de Fourier ne permet qu'une vision globale de la présence de chaque fréquence sur l'ensemble du signal. Mais un signal n'est pas homogène et évolue dans le temps, et certaines fréquences sont plus ou moins présentes selon l'instant considéré. La STFT va alors "découper" le signal selon des fenêtres à différents pas de temps, et effectuer une transformée de fourier (bien sûr on prendra aussi la FFT) sur chacun des morceaux obtenus. On dispose alors de la répartition des fréquences selon les pas de temps choisis. Il existe différents types de fenêtres qui "pondèrent" le signal d'une manière qui se veut optimale. Nous avons quant à nous choisi d'utiliser le modèle de la fenêtre de Hann, dont voici la formule:\\
\[
w[i]\ =\ \frac{1}{2}\left(1\ -\ cos(\frac{2i\pi}{N})\right)
\]
Où $N$ est la largeur choisie de la fenêtre, et $w$ est le tableau qui va pondérer la section du signal considérée (section qui est donc de largeur N, et qui démarre à un certain instant $t\ =\ k\times h$ où $h$ est le pas de temps choisi).   
\section*{Les filtres}
\large
Les filtres que l'on cherche à élaborer doivent être pensés selon le contexte d'utilisation de l'application (restaurant, bar, extérieur...). Nous avons donc dû lister (en en discutant notamment avec notre encadrant) un certain nombre de nuisances sonores que l'utilisateur trouverai bon d'éliminer ou de diminuer. Parmis ces nuisances on trouve: Le vent, les bruits de moteur, les bruits de couverts, les bruits parasites (crachement...), le brouhaha (ex: discussions voisines)... Au contraire on peut chercher à amplifier ou garder certaines parties du signal (musique, explication vocale de l'utilisateur...).\\
Nous avons dû éliminer rapidement les traitements qui paraissaient trop ambitieux dans le temps qui nous était imparti. Par exemple, supprimer le brouhaha ambiant dans un restaurant en gardant la voix de l'utilisateur peut constituer a priori un véritable tour de force (on veut traiter différemment des sources qui ont les mêmes plages de fréquence, des amplitudes pas nécessairement très éloignées...). On peut cependant (ce qui a d'ailleurs été une de nos idées de filtres durant une période) procéder à une sorte de reconnaissance vocale pour rehausser la voix de l'utilisateur (dont les caractéristiques sont connues a priori) par rapport au reste du signal.\\
\\
Nous avons finalement décidé de nous concentrer sur:\\
\begin{itemize}
\item Un filtre "Extérieur", à la fois anti-moteur et anti-vent, qui serait lui-même constitué:
\begin{itemize}

\item D'un passe-haut de fréquence de coupure $f_c \approx 400 Hz$ pour cibler les fréquences caractéristiques des moteurs de voiture et du vent "doux".
\item D'un filtre "anti-aberration", qui supprime localement les fluctuations trop importantes par rapport au reste du signal. Ce filtre est avant tout destiné à réduire l'impact d'un vent assez "fort", qui viendrait taper sur le micro.\\
\end{itemize}
\item Un Filtre "Musique" destiné comme son nom l'indique à rehausser la musique par rapport au bruit ambiant. Une première idée était d'appliquer un passe-bas sur le signal de manière à conserver les basses de la musique en diminuant les fréquences correspondant aux bruits de conversation, etc...\\
\item Un Filtre "Reconnaissance Vocale"' nous a paru pertinent en début de projet, en récupérant le spectre vocal de l'utilisateur sur un enregistrement à l'abris des nuisances sonores, pour ensuite comparer ce spectre à ceux des enregistrements futurs de l'utilisateur dans des milieux plus complexes.\\
\item En parallèle il nous paraissait intéressant de nous intéresser à des méthodes de filtrage du bruit (type crachement) pour deux raisons: D'abord il peut être naturellement présent dans certains enregistrements (qualité du micro, environnement...), et de plus, le fait d'appliquer certains filtres (comme le filtre "Extérieur") peut parfois détériorer la qualité du signal, en ajoutant justement ce type de bruit. Nous avons alors eu l'occasion de tester plusieurs types de filtres comme le filtre médian, le filtre "moyen"...\\
 Certains filtres anti-bruit déjà élaborés sont très efficaces, mais ils nécessitent en général de sélectionner une zone du signal où l'on entend que le bruit seul, pour pouvoir en déterminer la loi , ou densité de probabilité (si on revient dans la représentation du signal en variables aléatoires, surtout si le bruit est gaussien) ce qui permet par la suite de quasiment le supprimer sur tout le signal. Mais cela impliquerait une trop forte implication de l'utilisateur dans le processus de filtrage, qui se veut pourtant très simple et intuitif, pour une meilleure expérience. 
\end{itemize}
\chapter*{Programmation d'un prototype d'application}
\chapter*{Diffucultés générales}
\section*{Pendant la confection des filtres}
L'un des premiers obstacles qui est apparu rapidement est que si l'on se lance "à l'aveugle" dans le projet, on peut très vite se retrouver dans l'une des situations suivantes:\\
\begin{itemize}
\item On essai de dénicher un maximum de pistes de travail pour maximiser les chances d'en avoir quelques unes qui aboutissent à de bons résultats, mais on prend le risque de s'éparpiller.
\item On se concentre sur un nombre réduit de pistes (en fonction du nombre de personnes dans l'équipe) pour pouvoir bien les approfondir, mais si peu d'entre elles aboutissent, on se retrouve avec pas grand chose en terme de résultats. 
\end{itemize}
Il était donc essentiel de réduire le plus possible cette part d'aveugle en partant d'un socle solide: littérature sur le sujet, culture personnelle. Typiquement l'application de filtres passe-haut, passe-bas, passe-bande se trouve préférentiellement parmis les premières étapes, pour commencer à avancer en terrain connu.\\
\\
A cela s'est ajouté la difficulté à juger de la qualité d'un filtre. On peut en effet écouter les résultats pour certains enregistrements, mais comment être sûr que le filtre fonctionnera pour d'autres, pris dans un environnement différent ou avec des sources sonores supplémentaires? On peut bien sûr comparer les spectres et courbes temporelles des signaux avant et après traitement, ce qui permet de percevoir un peu plus concrètement comment le filtre agit sur le signal, mais cela reste très peu général.\\
\\
Enfin, on peut citer le réglage des paramètres. Chacun des filtres et presque chacune des fonctions qu'il utilise a été conçu(e) avec un certain nombre de paramètres (en arguments d'entrée en général) pour pouvoir maîtriser en partie son comportement (puissance de réduction des fréquences indésirables, taille des fenêtres de la STFT, fréquences de coupures, etc...). L'ajustement de ces paramètres s'est révélé aussi fastidieux que déterminent pour le fonctionnement des filtres. Et il est compliqué d'automatiser l'optimisation de ces paramètres étant donné que l'on ne dispose justement pas d'une fonction pouvant quantifier la qualité d'un filtre.

\section*{Au passage à l'application}
\chapter*{Conclusion et Perspectives}
\end{document}